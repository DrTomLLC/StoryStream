# .github/workflows/promote-on-ci.yml
# Promotes ONLY after CI succeeds, then creates/updates the PR and merges it.
# Flow: first-dev → stage-7-security → stage-9-final → main
name: Promote on CI success

on:
  workflow_run:
    workflows: ["CI"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  choose:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      from: ${{ steps.pick.outputs.from }}
      to: ${{ steps.pick.outputs.to }}
      sha: ${{ steps.sha.outputs.sha }}
      repo: ${{ steps.repo.outputs.repo }}
      owner: ${{ steps.repo.outputs.owner }}
    steps:
      - id: repo
        run: |
          FULL="${{ github.event.workflow_run.repository.full_name }}"
          echo "repo=${FULL#*/}" >> $GITHUB_OUTPUT
          echo "owner=${FULL%%/*}" >> $GITHUB_OUTPUT
      - id: sha
        run: echo "sha=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_OUTPUT
      - id: pick
        run: |
          ref="${{ github.event.workflow_run.head_branch }}"
          case "$ref" in
            first-dev)        echo "from=first-dev"         >> $GITHUB_OUTPUT; echo "to=stage-7-security" >> $GITHUB_OUTPUT ;;
            stage-7-security) echo "from=stage-7-security"  >> $GITHUB_OUTPUT; echo "to=stage-9-final"    >> $GITHUB_OUTPUT ;;
            stage-9-final)    echo "from=stage-9-final"     >> $GITHUB_OUTPUT; echo "to=main"             >> $GITHUB_OUTPUT ;;
            *) echo "No promotion for branch $ref"; exit 78 ;;
          esac

  promote:
    needs: choose
    if: ${{ always() && needs.choose.outputs.from != '' }}
    runs-on: ubuntu-latest
    steps:
      - name: Create or update PR, then merge if allowed
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = "${{ needs.choose.outputs.owner }}";
            const repo  = "${{ needs.choose.outputs.repo }}";
            const base  = "${{ needs.choose.outputs.to }}";
            const head  = "${{ needs.choose.outputs.from }}";
            const sha   = "${{ needs.choose.outputs.sha }}";

            // 1) Ensure target branch exists (create it from base of head if missing)
            async function ensureBranchExists(branch) {
              try {
                await github.rest.repos.getBranch({ owner, repo, branch });
              } catch (e) {
                if (e.status === 404) {
                  // create branch from current default's HEAD to unblock; caller can retarget later
                  const def = await github.rest.repos.get({ owner, repo });
                  const defaultBranch = def.data.default_branch;
                  const refData = await github.rest.git.getRef({ owner, repo, ref: `heads/${defaultBranch}` });
                  await github.rest.git.createRef({
                    owner, repo,
                    ref: `refs/heads/${branch}`,
                    sha: refData.data.object.sha
                  });
                } else { throw e; }
              }
            }
            await ensureBranchExists(base);

            // 2) Find existing PR head→base, or create one
            const prs = await github.rest.pulls.list({
              owner, repo, state: "open", head: `${owner}:${head}`, base
            });
            let pr = prs.data[0];
            if (!pr) {
              pr = (await github.rest.pulls.create({
                owner, repo, base, head,
                title: `Promote: ${head} → ${base}`,
                body: `Auto-promotion after CI success for \`${head}\`.\nCommit: ${sha}`
              })).data;
            } else {
              // Update PR body with the new SHA (helps traceability)
              await github.rest.pulls.update({
                owner, repo, pull_number: pr.number,
                body: `Auto-promotion after CI success for \`${head}\`.\nCommit: ${sha}`
              });
            }

            // 3) Try to merge it now (squash). If blocked (reviews/branch rules), leave PR open.
            try {
              await github.rest.pulls.merge({
                owner, repo, pull_number: pr.number,
                merge_method: "squash"
              });
              core.info(`Merged PR #${pr.number} ${head} → ${base}`);
            } catch (e) {
              core.warning(`Merge blocked: ${e.message}`);
              // Add a comment explaining what to do
              await github.rest.issues.createComment({
                owner, repo, issue_number: pr.number,
                body: [
                  "⚠️ Auto-merge blocked by repository rules (required reviews or checks).",
                  "Approve the PR or adjust branch protection, then merge.",
                  `Source: \`${head}\` → Target: \`${base}\`.`
                ].join("\n")
              });
            }
