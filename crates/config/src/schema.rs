//! Configuration schema generation
//!
//! This module generates JSON Schema and documented TOML templates
//! for IDE autocomplete and documentation purposes.

use crate::Config;

/// Generates a documented TOML config template
///
/// This creates a config file with inline comments explaining each option.
pub fn generate_documented_toml() -> String {
    let mut output = String::new();

    output.push_str("# StoryStream Configuration File\n");
    output.push_str("# This file is automatically generated with default values.\n");
    output.push_str("# Edit as needed - changes are validated on load.\n\n");

    output.push_str("# Configuration file format version\n");
    output.push_str("# Do not modify this unless you know what you're doing\n");
    output.push_str("version = 1\n\n");

    // App section
    output.push_str("[app]\n");
    output.push_str("# Path to the database file (relative to config dir if not absolute)\n");
    output.push_str("database_path = \"storystream.db\"\n\n");

    output.push_str("# Logging level: error, warn, info, debug, trace\n");
    output.push_str("log_level = \"info\"\n\n");

    output.push_str("# Enable debug mode for additional logging and checks\n");
    output.push_str("debug_mode = false\n\n");

    output.push_str("# Check for updates on startup\n");
    output.push_str("check_updates = true\n\n");

    output.push_str("# Send anonymous usage statistics (helps improve the app)\n");
    output.push_str("telemetry_enabled = false\n\n");

    output.push_str("# Color scheme: auto, light, dark\n");
    output.push_str("color_scheme = \"auto\"\n\n");

    output.push_str("# Maximum number of recent books to track\n");
    output.push_str("# Range: 1-100\n");
    output.push_str("max_recent_books = 10\n\n");

    output.push_str("# Enable experimental features (may be unstable)\n");
    output.push_str("experimental_features = false\n\n");

    // Player section
    output.push_str("[player]\n");
    output.push_str("# Default volume level (0-100)\n");
    output.push_str("default_volume = 70\n\n");

    output.push_str("# Default playback speed (0.5 - 2.0)\n");
    output.push_str("# 1.0 = normal speed, 1.5 = 1.5x faster, 0.75 = slower\n");
    output.push_str("default_speed = 1.0\n\n");

    output.push_str("# Auto-save playback position interval in seconds\n");
    output.push_str("# Range: 1-300\n");
    output.push_str("autosave_interval_secs = 5\n\n");

    output.push_str("# Automatically resume playback from last position\n");
    output.push_str("auto_resume = true\n\n");

    output.push_str("# Automatically skip silence in audio\n");
    output.push_str("skip_silence = false\n\n");

    output.push_str("# Rewind this many seconds when resuming playback\n");
    output.push_str("# Helps you remember where you left off\n");
    output.push_str("# Range: 0-60\n");
    output.push_str("resume_rewind_secs = 3\n\n");

    output.push_str("# UI refresh rate in milliseconds\n");
    output.push_str("# Lower = smoother but more CPU usage\n");
    output.push_str("# Range: 16-1000\n");
    output.push_str("ui_refresh_ms = 100\n\n");

    output.push_str("# Volume change step for increment/decrement commands\n");
    output.push_str("# Range: 1-50\n");
    output.push_str("volume_step = 5\n\n");

    output.push_str("# Playback speed change step\n");
    output.push_str("# Range: 0.05-0.5\n");
    output.push_str("speed_step = 0.1\n\n");

    // Library section
    output.push_str("[library]\n");
    output.push_str("# Paths to scan for audiobooks\n");
    output.push_str("# Add your audiobook directories here\n");
    output.push_str("library_paths = []\n");
    output.push_str("# Example:\n");
    output.push_str("# library_paths = [\"/home/user/audiobooks\", \"/media/audiobooks\"]\n\n");

    output.push_str("# Supported audio file extensions\n");
    output.push_str("supported_extensions = [\"mp3\", \"m4a\", \"m4b\", \"ogg\", \"opus\", \"flac\", \"wav\"]\n\n");

    output.push_str("# Automatically import new files when scanning\n");
    output.push_str("auto_import = false\n\n");

    output.push_str("# Extract metadata from audio files (title, author, etc.)\n");
    output.push_str("extract_metadata = true\n\n");

    output.push_str("# Recurse into subdirectories when scanning\n");
    output.push_str("recursive_scan = true\n\n");

    output.push_str("# Maximum recursion depth (0 = unlimited)\n");
    output.push_str("max_scan_depth = 0\n\n");

    output.push_str("# Skip files smaller than this size in bytes\n");
    output.push_str("# Helps filter out non-audiobook files\n");
    output.push_str("# Range: 0-104857600 (100 MB)\n");
    output.push_str("min_file_size_bytes = 1024\n\n");

    output.push_str("# Follow symbolic links when scanning\n");
    output.push_str("# Warning: Can cause infinite loops if links are circular\n");
    output.push_str("follow_symlinks = false\n\n");

    output.push_str("# Organize imported files by author/title\n");
    output.push_str("organize_files = false\n\n");

    output.push_str("# Target directory for organized files (required if organize_files = true)\n");
    output.push_str("# organization_target = \"/path/to/organized/audiobooks\"\n\n");

    output
}

/// Generates a JSON Schema for the configuration
///
/// This can be used by IDEs and editors for autocomplete and validation.
pub fn generate_json_schema() -> String {
    serde_json::json!({
        "$schema": "http://json-schema.org/draft-07/schema#",
        "title": "StoryStream Configuration",
        "description": "Configuration file for StoryStream audiobook player",
        "type": "object",
        "required": ["version", "app", "player", "library"],
        "properties": {
            "version": {
                "type": "integer",
                "description": "Configuration file format version",
                "const": 1
            },
            "app": {
                "type": "object",
                "description": "Application-level settings",
                "properties": {
                    "database_path": {
                        "type": "string",
                        "description": "Path to the database file"
                    },
                    "log_level": {
                        "type": "string",
                        "enum": ["error", "warn", "info", "debug", "trace"],
                        "description": "Logging verbosity level"
                    },
                    "debug_mode": {
                        "type": "boolean",
                        "description": "Enable debug mode"
                    },
                    "check_updates": {
                        "type": "boolean",
                        "description": "Check for updates on startup"
                    },
                    "telemetry_enabled": {
                        "type": "boolean",
                        "description": "Send anonymous usage statistics"
                    },
                    "color_scheme": {
                        "type": "string",
                        "enum": ["auto", "light", "dark"],
                        "description": "UI color scheme"
                    },
                    "max_recent_books": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 100,
                        "description": "Maximum recent books to track"
                    },
                    "experimental_features": {
                        "type": "boolean",
                        "description": "Enable experimental features"
                    }
                }
            },
            "player": {
                "type": "object",
                "description": "Player preferences",
                "properties": {
                    "default_volume": {
                        "type": "integer",
                        "minimum": 0,
                        "maximum": 100,
                        "description": "Default volume level"
                    },
                    "default_speed": {
                        "type": "number",
                        "minimum": 0.5,
                        "maximum": 2.0,
                        "description": "Default playback speed"
                    },
                    "autosave_interval_secs": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 300,
                        "description": "Auto-save interval in seconds"
                    },
                    "auto_resume": {
                        "type": "boolean",
                        "description": "Resume from last position"
                    },
                    "skip_silence": {
                        "type": "boolean",
                        "description": "Skip silence automatically"
                    },
                    "resume_rewind_secs": {
                        "type": "integer",
                        "minimum": 0,
                        "maximum": 60,
                        "description": "Rewind seconds when resuming"
                    },
                    "ui_refresh_ms": {
                        "type": "integer",
                        "minimum": 16,
                        "maximum": 1000,
                        "description": "UI refresh rate in milliseconds"
                    },
                    "volume_step": {
                        "type": "integer",
                        "minimum": 1,
                        "maximum": 50,
                        "description": "Volume increment/decrement step"
                    },
                    "speed_step": {
                        "type": "number",
                        "minimum": 0.05,
                        "maximum": 0.5,
                        "description": "Speed increment/decrement step"
                    }
                }
            },
            "library": {
                "type": "object",
                "description": "Library and import settings",
                "properties": {
                    "library_paths": {
                        "type": "array",
                        "items": { "type": "string" },
                        "description": "Directories to scan for audiobooks"
                    },
                    "supported_extensions": {
                        "type": "array",
                        "items": { "type": "string" },
                        "description": "Supported audio file extensions"
                    },
                    "auto_import": {
                        "type": "boolean",
                        "description": "Auto-import discovered files"
                    },
                    "extract_metadata": {
                        "type": "boolean",
                        "description": "Extract metadata from files"
                    },
                    "recursive_scan": {
                        "type": "boolean",
                        "description": "Recurse into subdirectories"
                    },
                    "max_scan_depth": {
                        "type": "integer",
                        "minimum": 0,
                        "description": "Maximum recursion depth (0=unlimited)"
                    },
                    "min_file_size_bytes": {
                        "type": "integer",
                        "minimum": 0,
                        "maximum": 104857600,
                        "description": "Minimum file size in bytes"
                    },
                    "follow_symlinks": {
                        "type": "boolean",
                        "description": "Follow symbolic links"
                    },
                    "organize_files": {
                        "type": "boolean",
                        "description": "Organize by author/title"
                    },
                    "organization_target": {
                        "type": ["string", "null"],
                        "description": "Target directory for organized files"
                    }
                }
            }
        }
    })
    .to_string()
}

/// Generates a config with all possible values set to demonstrate options
pub fn generate_example_config() -> Config {
    let mut config = Config::default();

    // Set some non-default values to show possibilities
    config.player.default_volume = 75;
    config.player.default_speed = 1.2;
    config.player.skip_silence = true;
    config.library.auto_import = true;
    config.library.library_paths = vec![
        std::path::PathBuf::from("/home/user/audiobooks"),
        std::path::PathBuf::from("/media/audiobooks"),
    ];

    config
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_documented_toml() {
        let toml = generate_documented_toml();

        // Should contain section headers
        assert!(toml.contains("[app]"));
        assert!(toml.contains("[player]"));
        assert!(toml.contains("[library]"));

        // Should contain comments
        assert!(toml.contains("# Default volume"));

        // Should be valid TOML
        let parsed: Result<Config, _> = toml::from_str(&toml);
        assert!(parsed.is_ok());
    }

    #[test]
    fn test_generate_json_schema() {
        let schema = generate_json_schema();

        // Should be valid JSON
        let parsed: Result<serde_json::Value, _> = serde_json::from_str(&schema);
        assert!(parsed.is_ok());

        let json = parsed.unwrap();

        // Should have required fields
        assert!(json["properties"]["version"].is_object());
        assert!(json["properties"]["app"].is_object());
        assert!(json["properties"]["player"].is_object());
        assert!(json["properties"]["library"].is_object());
    }

    #[test]
    fn test_generate_example_config() {
        let config = generate_example_config();

        // Should be valid
        assert!(config.validate().is_ok());

        // Should have some non-default values
        assert_eq!(config.player.default_volume, 75);
        assert!(config.library.auto_import);
    }

    #[test]
    fn test_documented_toml_parses_to_valid_config() {
        let toml = generate_documented_toml();
        let config: Config = toml::from_str(&toml).expect("Should parse");

        assert!(config.validate().is_ok());
        assert_eq!(config, Config::default());
    }
}
